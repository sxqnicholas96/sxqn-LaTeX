%!TEX root = ./Technical_Interview_CS.tex

\documentclass[12pt, a4paper]{article}
\usepackage{geometry}
\usepackage{mathtools}
\usepackage{enumitem}
\usepackage{fullpage}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{hyperref}
\usepackage{fancyvrb,xcolor}

\newcommand{\code}[1]{\texttt{#1}}

\definecolor{test}{gray}{0.93}

\newenvironment{lcverbatim}
 {\SaveVerbatim{cverb}}
 {\endSaveVerbatim
  \flushleft\fboxrule=0pt\fboxsep=.5em
  \colorbox{test}{%
    \makebox[\dimexpr\linewidth-2\fboxsep][l]{\BUseVerbatim{cverb}}%
  }
  \endflushleft
}

\hypersetup{
    colorlinks,
    citecolor=black,
    filecolor=black,
    linkcolor=black,
    urlcolor=black
}

\newcommand\Perm[2][^n]{\prescript{#1\mkern-2.5mu}{}P_{#2}}
\newcommand\Comb[2][^n]{\prescript{#1\mkern-0.5mu}{}C_{#2}}

\setlength{\parindent}{0pt} % Set paragraph indent to 0 spaces

\graphicspath{./}
\geometry{a4paper, margin=0.7in}

\begin{document}
\noindent

\tableofcontents

\pagebreak

\addcontentsline{toc}{section}{Software Engineering Principles}
\section*{Software Engineering Principles}
\subsubsection*{What are the SOLID principles?}
\begin{enumerate}
  \item Single Responsibility - A class should have only one responsibility, and hence only one reason to change.
  \item Open/Closed - Classes should be open for extension, but closed for modification.
  \item Liskov Substituition - if B is a class subtype of A, then we can replace all instances of B with A without disrupting the program.
  \item Interface Segregation - Large interfaces should be split into smaller, focused chunks.
  \item Dependency Inversion - Instead of high-level modules depending on low-level modules, both will depend on abstractions.
\end{enumerate}

Detailed explanations for each principle can reference \href{https://www.baeldung.com/solid-principles}{here at Baeldung}

\pagebreak
\addcontentsline{toc}{section}{Concepts in Operating Systems}
\section*{Concepts in Operating Systems}
\subsubsection*{What is the difference between a Task, Process and Threads?}


\pagebreak
\addcontentsline{toc}{section}{Languages}
\section*{Languages}
\addcontentsline{toc}{subsection}{C/C++}
\subsection*{C/C++}

\pagebreak
\addcontentsline{toc}{subsection}{JavaScript}
\subsection*{JavaScript}
\subsubsection*{What is the \code{prototype} object in JavaScript}
JavaScript is often described as a prototype-based language.
Objects can have a \code{prototype} object, which acts as a template object that it inherits methods and properties from.
In JavaScript, a link is made between the object instance and its prototype (\code{\_\_proto\_\_} property, derived from \code{prototype} property from the constructor)

\subsubsection*{What are the primitive data types in JavaScript}
There are 7 primitive data types: \code{string}, \code{number}, \code{bigint}, \code{undefined}, \code{boolean}, \code{symbol} and \code{null}.

\subsubsection*{What are the keywords \code{async}/\code{await} and the \code{Promise} object used for}
The \code{async} keyword is always used to define an asynchronous function, which would then always return a \code{Promise} object.\newline
The \code{await} keyword can \textbf{only be used in defined, asynchronous functions}, makes JavaScript wait until that promise resolves, and then returns the result.
\code{await} \textbf{only} suspends function execution in which it has been used.
In the meantime, the JavaScript can handle other jobs like executing scripts or handle events etc.\newline
The \code{Promise} object represents the eventual completion and failure of an asynchronous operation and its resulting value.
A \code{Promise} can be in one of 3 states:
\begin{itemize}
    \item \code{pending} - the asynchronous action is pending resolution, neither fulfilled nor rejected
    \item \code{fulfilled}/\code{resolved} - the asynchronous action has completed successfully
    \item \code{rejected} - The operation has failed
\end{itemize}

\subsubsection*{Why are callbacks used extensively in JavaScript}
Callbacks are used in JavaScript to execute code after an asynchronous action has resolved.

\subsubsection*{What is Babel and what is its use in JavaScript projects}
Babel is a JavaScript compiler toolchain that helps developers transpile JavaScript code into backwards-compatible versions of itself to accommodate older browsers and environments.
This is because older browser versions often are unable to support newer versions of JavaScript.

\subsubsection*{What is \code{Promise.all} and \code{Promise.race}}
\code{Promise.all} accepts an array of promises, and attempts to fulfill all of them.
Exits early if just 1 promise gets rejected.\newline
\code{Promise.race} accepts an array of promises, but only returns the \code{Promise} that returns first.

\subsubsection*{What is currying in JavaScript?}
Currying is a technique of evaluating a function with multiple arguments, into a sequence of functional calls, each with a single arguments.\newline
Currying works by natural closure, where the nested functions retain access to variables in higher order functions.
Hence the innermost function have access to all variables.

\subsubsection*{What is the concept of closures in JavaScript}
The concept of closure refers to the combination of a function bundled together with references to its surrounding state or lexical environment, within which the function was declared.
Whenever you create a function within another function, you have created a closure.
In JavaScript, closures are created every time is created, at function creation time.
\begin{lcverbatim}
function makeFunc() {
    var name = 'Mozilla';
    function displayName() {
            alert(name);
        }
    return displayName
}
var myFunc = makeFunc();
myFunc();
\end{lcverbatim}

As in the above code, the instance of displayName maintains a reference to its lexical environment, and hence is able to access the variable \code{name} in the outer function.

% TODO
\subsubsection*{Compare Global scope vs Local scope vs Function scoping vs Block-scoping}
\textbf{Global scope} refers to variables declared outside all functions or curly braces.\newline
\textbf{Local scope} refers to variables declared that is only accessible in a specific part of the code.
\begin{itemize}
    \item \textbf{Function scope} refers to lexical environment enclosed within a function.
    \item \textbf{Block scope} refers to the lexical environment enclosed within a curly brace.
\end{itemize}

\subsubsection*{What does hoisting mean in JavaScript}
Hoisting is a JavaScript mechanism where variables and function declarations are moved to the top of their scope before code execution.

\subsubsection*{Difference between Class Expressions and Class Declarations}
\begin{lcverbatim}
// Class declaration
class Square {
    constructor(length) {
        this.length = length;
    }
}
// Class expressions
let Square = class {          // unamed, Square.name = "Square"
  constructor(length) {
    this.length = length;
  }
};

let Square = class Square2 {  // named, Square.name = "Square2"
  constructor(length) {
    this.length = length;
  }
};
\end{lcverbatim}

Both class expressions and declarations are not hoisted during compile time, unlike function declarations.

\subsubsection*{What is the \code{new} keyword in JavaScript for?}
The \code{new} keyword is used to create an instance of an object that has the constructor function.
\begin{enumerate}
    \item A new empty object is created.
    \item The new object’s internal ‘Prototype’ property (\code{\_\_proto\_\_}) is set the same as the prototype of the constructing function.
    \item The \code{this} variable is made to point to the newly created object. It binds the property which is declared with \code{this} keyword to the new object.
    \item A newly created object is returned when the constructor function returns a non-primitive value (custom JavaScript object).
          If the constructor function returns a primitive value, it will be ignored.
          At the end of the function, ‘this’ is returned if there is no return statement in the function body.    
\end{enumerate}

\subsubsection*{Difference between \code{Object} and \code{Map}}
\begin{itemize}
  \item \textbf{Accidental Keys} - \code{Map} does not contain any keys by default, while an \code{Object} has a prototype (contains default keys)
  \item \textbf{Key Types} - A \code{Map}'s keys can be any value, while the keys of an \code{Object} must be a \code{String} or \code{Symbol}
  \item \textbf{Key Order} - Keys in \code{Map} ordered in the order of entry insertion, while keys in \code{Object} have arbitrary/unreliable ordering. 
\end{itemize}

\subsubsection*{Difference between \code{const}, \code{let} and \code{var}}
\begin{itemize}
  \item \code{var} is globally scoped when declared outside a function, and functionally scoped when declared within a function.\newline
        \code{var} declarations are hoisted to the top, and will be initialised with a value of \code{undefined}
  \item \code{const} and \code{let} is block scoped.\newline
        \code{let} and \code{const} declarations are hoisted to the top, but will not be initialised.
\end{itemize}

\subsubsection*{What's the difference between function declarations, function expressions and arrow functions? In which contexts would you use each type?}
\begin{itemize}
  \item \textbf{Function Declarations}
  \begin{lcverbatim}
  function add(a, b) {
    return a + b;
  }
  \end{lcverbatim}
  Each function declaration must be accompanied by its name and are hoisted.
  \item \textbf{Function Expressions}
  \begin{lcverbatim}
  var add = function(a, b) { // unamed
    return a + b;
  };
  \end{lcverbatim}
  \begin{lcverbatim}
  var add = function add(a, b) { // named
    return a + b;
  };
  \end{lcverbatim}
  Function expressions are not hoisted. 
  The \code{var} declaration is hoisted, but is initialised with a value of \code{undefined}
  \item \textbf{Arrow Functions}
  \begin{lcverbatim}
  var add = (a, b) => a + b;
  \end{lcverbatim}
  Arrow functions behave mostly like function expressions, and are not hoisted.
  Arrow functions cannot be named, and lexically binds(inherits from its enclosing scope) the current \code{this} value.
  Function declarations and function expressions, however, own their own \code{this} value.
\end{itemize}

\pagebreak

\addcontentsline{toc}{subsection}{Scala}
\subsection*{Scala}

\subsubsection*{Difference between \code{class} and \code{object}}
A \code{class} definition is a template that we can use to create objects from.
A class instance is the actual object created from the template.
Scala provides the \code{object} keyword that allows us to create singleton objects directly.
That is to say, an object declared using the \code{object} keyword can only have a single instance, or only instantiated once.

\subsubsection*{What are implicit classes?}
They are classes marked with the \code{implicit} keyword.
This allows the class's primary constructor to be available for implicit conversions when the class in scope.\newline

Implicit class declarations have the following restrictions:
\begin{itemize}
  \item They must be defined inside of another \code{trait}/\code{class}/\code{object}
  \item Only one non-implicit argument is allowed in their constructor
  \item The name of implicit class must not collide with other declarations within the same scope, and implies implicit classes cannot be case classes
\end{itemize}


\pagebreak

\addcontentsline{toc}{subsection}{TypeScript}
\subsection*{TypeScript}

\pagebreak

\addcontentsline{toc}{section}{Frameworks}
\section*{Frameworks}
\subsection*{React}

\end{document}