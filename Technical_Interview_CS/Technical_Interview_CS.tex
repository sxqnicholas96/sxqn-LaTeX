%!TEX root = ./Technical_Interview_CS.tex

\documentclass[12pt, a4paper]{article}
\usepackage{listings} %code extracts
\usepackage{xcolor} %custom colours
\usepackage{mdframed} %nice frames
\usepackage{geometry}
\usepackage{mathtools}
\usepackage{enumitem}
\usepackage{fullpage}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{hyperref}
\usepackage{fancyvrb,xcolor}

\newcommand{\code}[1]{\texttt{#1}}

\definecolor{light-gray}{gray}{0.95} %the shade of grey that stack exchange uses

\definecolor{test}{gray}{0.93}

\lstdefinelanguage{JavaScript}{
  keywords={typeof, new, true, false, catch, function, return, null, catch, switch, var, if, in, while, do, else, case, break},
  keywordstyle=\color{blue}\bfseries,
  ndkeywords={class, export, boolean, throw, implements, import, this},
  ndkeywordstyle=\color{darkgray}\bfseries,
  identifierstyle=\color{black},
  sensitive=false,
  comment=[l]{//},
  morecomment=[s]{/*}{*/},
  commentstyle=\color{purple}\ttfamily,
  stringstyle=\color{red}\ttfamily,
  morestring=[b]',
  morestring=[b]"
}

\lstset{
   language=JavaScript,
   extendedchars=true,
   basicstyle=\footnotesize\ttfamily,
   showstringspaces=false,
   showspaces=false,
   numbers=left,
   numberstyle=\footnotesize,
   numbersep=9pt,
   tabsize=2,
   breaklines=true,
   showtabs=false,
   captionpos=b
}

\hypersetup{
    colorlinks,
    citecolor=black,
    filecolor=black,
    linkcolor=black,
    urlcolor=blue,
}

\newcommand\Perm[2][^n]{\prescript{#1\mkern-2.5mu}{}P_{#2}}
\newcommand\Comb[2][^n]{\prescript{#1\mkern-0.5mu}{}C_{#2}}

\setlength{\parindent}{0pt} % Set paragraph indent to 0 spaces

\graphicspath{./}
\geometry{a4paper, margin=0.7in}

\begin{document}
\noindent

\tableofcontents

\pagebreak

\section*{Software Engineering}
\addcontentsline{toc}{section}{Software Engineering Principles}

\subsection*{Object-Oriented Programming (OOP)}
\addcontentsline{toc}{subsection}{Object-Oriented Programming (OOP)}

\subsubsection*{What are the SOLID principles?}
\begin{enumerate}
  \item Single Responsibility - A class should have only one responsibility, and hence only one reason to change.
  \item Open/Closed - Classes should be open for extension, but closed for modification.
  \item Liskov Substituition - if B is a class subtype of A, then we can replace all instances of B with A without disrupting the program.
  \item Interface Segregation - Large interfaces should be split into smaller, focused chunks.
  \item Dependency Inversion - Instead of high-level modules depending on low-level modules, both will depend on abstractions.
\end{enumerate}

Detailed explanations for each principle can reference \href{https://www.baeldung.com/solid-principles}{here at Baeldung}

\pagebreak
\section*{Concepts in Operating Systems}
\addcontentsline{toc}{section}{Concepts in Operating Systems}
\subsubsection*{What is the difference between a Task, Process and Threads?}


\pagebreak
\section*{Languages}
\addcontentsline{toc}{section}{Languages}

\subsection*{C/C++}
\addcontentsline{toc}{subsection}{C/C++}


\pagebreak
\subsection*{JavaScript}
\addcontentsline{toc}{subsection}{JavaScript}
\subsubsection*{What is the \code{prototype} object in JavaScript}
JavaScript is often described as a prototype-based language.
Objects can have a \code{prototype} object, which acts as a template object that it inherits methods and properties from.
In JavaScript, a link is made between the object instance and its prototype (\code{\_\_proto\_\_} property, derived from \code{prototype} property from the constructor)

\subsubsection*{What are the primitive data types in JavaScript}
There are 7 primitive data types: \code{string}, \code{number}, \code{bigint}, \code{undefined}, \code{boolean}, \code{symbol} and \code{null}.

\subsubsection*{What are the keywords \code{async}/\code{await} and the \code{Promise} object used for}
The \code{async} keyword is always used to define an asynchronous function, which would then always return a \code{Promise} object.\newline
The \code{await} keyword can \textbf{only be used in defined, asynchronous functions}, makes JavaScript wait until that promise resolves, and then returns the result.
\code{await} \textbf{only} suspends function execution in which it has been used.
In the meantime, the JavaScript can handle other jobs like executing scripts or handle events etc.\newline
The \code{Promise} object represents the eventual completion and failure of an asynchronous operation and its resulting value.
A \code{Promise} can be in one of 3 states:
\begin{itemize}
    \item \code{pending} - the asynchronous action is pending resolution, neither fulfilled nor rejected
    \item \code{fulfilled}/\code{resolved} - the asynchronous action has completed successfully
    \item \code{rejected} - The operation has failed
\end{itemize}

\subsubsection*{Why are callbacks used extensively in JavaScript}
Callbacks are used in JavaScript to execute code after an asynchronous action has resolved.

\subsubsection*{What is Babel and what is its use in JavaScript projects}
Babel is a JavaScript compiler toolchain that helps developers transpile JavaScript code into backwards-compatible versions of itself to accommodate older browsers and environments.
This is because older browser versions often are unable to support newer versions of JavaScript.

\subsubsection*{What is \code{Promise.all} and \code{Promise.race}}
\code{Promise.all} accepts an array of promises, and attempts to fulfill all of them.
Exits early if just 1 promise gets rejected.\newline
\code{Promise.race} accepts an array of promises, but only returns the \code{Promise} that returns first.

\subsubsection*{What is currying in JavaScript?}
Currying is a technique of evaluating a function with multiple arguments, into a sequence of functional calls, each with a single arguments.\newline
Currying works by natural closure, where the nested functions retain access to variables in higher order functions.
Hence the innermost function have access to all variables.

\subsubsection*{What is the concept of closures in JavaScript}
The concept of closure refers to the combination of a function bundled together with references to its surrounding state or lexical environment, within which the function was declared.
Whenever you create a function within another function, you have created a closure.
In JavaScript, closures are created every time is created, at function creation time.
\begin{mdframed}[backgroundcolor=light-gray, roundcorner=10pt,leftmargin=1, rightmargin=1, innerleftmargin=20, innertopmargin=5,innerbottommargin=5, outerlinewidth=1, linecolor=light-gray]
\begin{lstlisting}[language=JavaScript]
function makeFunc() {
    var name = 'Mozilla';
    function displayName() {
            alert(name);
        }
    return displayName
}
var myFunc = makeFunc();
myFunc();

\end{lstlisting}
\end{mdframed}


As in the above code, the instance of displayName maintains a reference to its lexical environment, and hence is able to access the variable \code{name} in the outer function.

% TODO
\subsubsection*{Compare Global scope vs Local scope vs Function scoping vs Block-scoping}
\textbf{Global scope} refers to variables declared outside all functions or curly braces.\newline
\textbf{Local scope} refers to variables declared that is only accessible in a specific part of the code.
\begin{itemize}
    \item \textbf{Function scope} refers to lexical environment enclosed within a function.
    \item \textbf{Block scope} refers to the lexical environment enclosed within a curly brace.
\end{itemize}

\subsubsection*{What does hoisting mean in JavaScript}
Hoisting is a JavaScript mechanism where variables and function declarations are moved to the top of their scope before code execution.

\subsubsection*{Difference between Class Expressions and Class Declarations}
\begin{mdframed}[backgroundcolor=light-gray, roundcorner=10pt,leftmargin=1, rightmargin=1, innerleftmargin=20, innertopmargin=5,innerbottommargin=5, outerlinewidth=1, linecolor=light-gray]
\begin{lstlisting}[language=JavaScript]
// Class declaration
class Square {
    constructor(length) {
        this.length = length;
    }
}
// Class expressions
let Square = class {          // unamed, Square.name = "Square"
  constructor(length) {
    this.length = length;
  }
};

let Square = class Square2 {  // named, Square.name = "Square2"
  constructor(length) {
    this.length = length;
  }
};
\end{lstlisting}
\end{mdframed}

Both class expressions and declarations are not hoisted during compile time, unlike function declarations.

\subsubsection*{What is the \code{new} keyword in JavaScript for?}
The \code{new} keyword is used to create an instance of an object that has the constructor function.
\begin{enumerate}
    \item A new empty object is created.
    \item The new object’s internal ‘Prototype’ property (\code{\_\_proto\_\_}) is set the same as the prototype of the constructing function.
    \item The \code{this} variable is made to point to the newly created object. It binds the property which is declared with \code{this} keyword to the new object.
    \item A newly created object is returned when the constructor function returns a non-primitive value (custom JavaScript object).
          If the constructor function returns a primitive value, it will be ignored.
          At the end of the function, ‘this’ is returned if there is no return statement in the function body.    
\end{enumerate}

\subsubsection*{Difference between \code{Object} and \code{Map}}
\begin{itemize}
  \item \textbf{Accidental Keys} - \code{Map} does not contain any keys by default, while an \code{Object} has a prototype (contains default keys)
  \item \textbf{Key Types} - A \code{Map}'s keys can be any value, while the keys of an \code{Object} must be a \code{String} or \code{Symbol}
  \item \textbf{Key Order} - Keys in \code{Map} ordered in the order of entry insertion, while keys in \code{Object} have arbitrary/unreliable ordering. 
\end{itemize}

\subsubsection*{Difference between \code{const}, \code{let} and \code{var}}
\begin{itemize}
  \item \code{var} is globally scoped when declared outside a function, and functionally scoped when declared within a function.\newline
        \code{var} declarations are hoisted to the top, and will be initialised with a value of \code{undefined}
  \item \code{const} and \code{let} is block scoped.\newline
        \code{let} and \code{const} declarations are hoisted to the top, but will not be initialised.
\end{itemize}

\subsubsection*{What's the difference between function declarations, function expressions and arrow functions? In which contexts would you use each type?}
\begin{itemize}
  \item \textbf{Function Declarations}
  \begin{mdframed}[backgroundcolor=light-gray, roundcorner=10pt,leftmargin=1, rightmargin=1, innerleftmargin=20, innertopmargin=5,innerbottommargin=5, outerlinewidth=1, linecolor=light-gray]
  \begin{lstlisting}[language=JavaScript]
  function add(a, b) {
    return a + b;
  }
  \end{lstlisting}
  \end{mdframed}
  Each function declaration must be accompanied by its name and are hoisted.
  \item \textbf{Function Expressions}
  \begin{mdframed}[backgroundcolor=light-gray, roundcorner=10pt,leftmargin=1, rightmargin=1, innerleftmargin=20, innertopmargin=5,innerbottommargin=5, outerlinewidth=1, linecolor=light-gray]
  \begin{lstlisting}[language=JavaScript]
  var add = function(a, b) { // unamed
    return a + b;
  };
  \end{lstlisting}
  \end{mdframed}
  \begin{mdframed}[backgroundcolor=light-gray, roundcorner=10pt,leftmargin=1, rightmargin=1, innerleftmargin=20, innertopmargin=5,innerbottommargin=5, outerlinewidth=1, linecolor=light-gray]
  \begin{lstlisting}[language=JavaScript]
  var add = function add(a, b) { // named
    return a + b;
  };
  \end{lstlisting}
  \end{mdframed}
  Function expressions are not hoisted. 
  The \code{var} declaration is hoisted, but is initialised with a value of \code{undefined}
  \item \textbf{Arrow Functions}
  \begin{mdframed}[backgroundcolor=light-gray, roundcorner=10pt,leftmargin=1, rightmargin=1, innerleftmargin=20, innertopmargin=5,innerbottommargin=5, outerlinewidth=1, linecolor=light-gray]
  \begin{lstlisting}[language=JavaScript]
  var add = (a, b) => a + b;
  \end{lstlisting}
  \end{mdframed}
  Arrow functions behave mostly like function expressions, and are not hoisted.
  Arrow functions cannot be named, and lexically binds(inherits from its enclosing scope) the current \code{this} value.
  Function declarations and function expressions, however, own their own \code{this} value.
\end{itemize}

\pagebreak

\subsection*{TypeScript}
\addcontentsline{toc}{subsection}{TypeScript}


\subsubsection*{What's the difference between JavaScript and TypeScript}
TypeScript is a superset of vanilla JavaScript, providing additional features such as static typing (type-checking at compile-time) and is strongly typed.
TypeScript is mostly considered to be a programming language, that eventually compiles to vanilla JavaScript.\newline
JavaScript is dynamically typed and is mostly considered to be scripting language that has to be interpreted on the fly by JavaScript engines.

\subsubsection*{Difference between \code{type} and \code{interface} declarations in TypeScript}
\code{type} declarations cannot be "re-opened" to add new properties vs an \code{interface} which is always extendable.
\href{https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#differences-between-type-aliases-and-interfaces}{See here}

\subsubsection*{What are type assertions and when should you use them}
Type assertions can be used when the developer is confident of knowing more about a value then TypeScript.
It is a way of telling the TypeScript compiler, "trust me, I know what I'm doing", and TypeScript assumes that you, the programmer have performed any special checks you need.
Type assertions have 2 forms, the \code{as}-syntax and the "angle-bracket" syntax.

Usage of type assertions is highly discouraged in code.
Responsibility of checking types should be given to the TypeScript compiler as much as possible.

\subsubsection*{What are some disadvantages of using Javascript over TypeScript}
It takes some time to compile TypeScript code and check type errors, while JavaScript code can be immediately interpreted.

\subsubsection*{What are type generics used in TypeScript for}
Type generics allow us to create reusable types and interfaces.
This is especially useful when different objects share very similar attributes, we can simply declare an interface with a generic type to describe them all.

\subsubsection*{What is the difference between using \code{any} and \code{unknown}}
\code{unknown} is much less permissive than \code{any}, and is considered the type-safe counterpart of \code{any}.
This is enforced by the TypeScript compiler, where no operations are permitted without first asserting and narrowing an \code{unknown} variable to a more specific type.

\pagebreak

\subsection*{Scala}
\addcontentsline{toc}{subsection}{Scala}

\subsubsection*{Difference between \code{class} and \code{object}}
A \code{class} definition is a template that we can use to create objects from.
A class instance is the actual object created from the template.
Scala provides the \code{object} keyword that allows us to create singleton objects directly.
That is to say, an object declared using the \code{object} keyword can only have a single instance, or only instantiated once.

\subsubsection*{What are implicit classes?}
They are classes marked with the \code{implicit} keyword.
This allows the class's primary constructor to be available for implicit conversions when the class in scope.\newline

Implicit class declarations have the following restrictions:
\begin{itemize}
  \item They must be defined inside of another \code{trait}/\code{class}/\code{object}
  \item Only one non-implicit argument is allowed in their constructor
  \item The name of implicit class must not collide with other declarations within the same scope, and implies implicit classes cannot be case classes
\end{itemize}

\pagebreak

\section*{Database}
\addcontentsline{toc}{section}{Database}
\subsubsection*{What are the ACID properties of transactions?}
\begin{itemize}
  \item \textbf{Atomicity} All changes to data in a transaction are performed as if they are a single operation.
        All intended changes are performed, or none of them are.
  \item \textbf{Consistency} Execution of a transaction in isolation preseves the consistency of data in the database.
  \item \textbf{Isolation} Execution of a transaction is isolated from the effects of other transactions in concurrent execution.
  \item \textbf{Durability} Effects of a committed transaction persist even in the presence of system failures.
\end{itemize}

\subsubsection*{What's the difference between NoSQL and SQL databases? What is the difference in use case?}
\begin{itemize}
  \item SQL databases are relational and enforces a strict schema that describes relationships between different data entities and is ACID-compliant.
        NoSQL databases are non-relational and do not enforce relationships between entities.
  \item SQL uses the SQL query language and must have a predefined schema while NoSQL databases have dynamic schemas to store unstructured data.
  \item SQL databases are vertically scalable, NoSQL are horizontally scalable.
  \item SQL databases are table based, while NoSQL databases are document, key-value, graph or wide-column stores.
  \item SQL databases are better for multi-row transactions, NoSQL are better for unstructured data like documents or JSON.
\end{itemize}

Reference: \url{https://www.xplenty.com/blog/the-sql-vs-nosql-difference/}

\subsubsection*{What is a primary key for?}
Since primary keys uniquely identifies a row in a database table, it is usually used to index tables.

\subsubsection*{What is a composite primary key used for?}
Composite primary keys are usually used to express many-to-many relationships or weak entity sets.

\subsubsection*{What is database normalization?}
Normalization is a process of organizing data in a database to avoid data redundancy, insertion anomaly, update anomaly and deletion anomaly.

Some examples of normal forms are 1NF, 2NF, 3NF BCNF.

\pagebreak

\section*{Docker}
\addcontentsline{toc}{section}{Docker}
\subsubsection*{What's the difference between a docker container and a virtual machine}
A docker container runs in the same operating system as the host OS, while a virtual machine runs on a separate OS.
Essentially, a container is just a set of processes that are isolated from the rest of the system, running from a distinct image that provides all files necessary to support the processes.
To isolate containers, docker uses \code{namespaces}. 
\code{namespaces} provide a layer of isolation, with each container running in a separate namespace and its access is limited to that namespace.

Under VMs, computing hardware resources are virtualised and accesses to computing resources are managed by the VM software.

\subsubsection*{What is a docker repository and what is its use case}
Similar to Github repositories where it is used to share code, Docker repositories are used to share docker images.
This is useful when we want to ensure consistency across development, staging and production environments.

\pagebreak

\section*{Frameworks}
\addcontentsline{toc}{section}{Frameworks}

\subsection*{React}
\addcontentsline{toc}{subsection}{React}

\subsubsection*{What is the React Lifecycle}
Each React component you build has a lifecycle which you can monitor and manipulate during its three main phases:
\begin{itemize}
  \item \textbf{Mounting} refers to when the component has to be rendered for the first time, and React has to build the initial DOM for the component.
  \item \textbf{Updating} refers to when the component is updating(e.g. component state update, \code{props} change)
  \item \textbf{Unmounting} refers to when the component is to be removed from the React DOM, and corresponding cleanup code is called
\end{itemize}

More on what methods are called during each phase \href{https://www.w3schools.com/react/react_lifecycle.asp}{here}

\subsubsection*{What is the advantage of using React Hooks w/ React Functional Components vs React Class Components?}
\begin{itemize}
  \item With React Hooks, stateful logic is decoupled from UI and allows us to reuse the logic across multiple React components, by refactoring out hook logic into a separate module.
  \item React Hooks avoids having to use method bindings and the \code{this} keyword, which can be confusing for developers.
  \item React Hooks can help to simplify and organise code to improve readability, while Class Components often become very complex and difficult to simplify.
\end{itemize}

\subsubsection*{What is prop drilling? How to prevent prop drilling?}
Prop drilling is when \code{props} are passed through layers of components that do not need the data, eventually reaching the component that actually uses it.
This is not ideal, as it would imply everytime we add/remove a prop needed by the targeted component, we would need to modify code for the intermediate components as well.

To prevent prop drilling, can use \href{https://reactjs.org/docs/context.html}{React Context} or any state management container library such as \href{https://redux.js.org/introduction/getting-started}{Redux} or \href{https://mobx.js.org/README.html}{MobX}.

\subsubsection*{How would you faciliate communications between components in React?}
Communications here mean a triggered function causes an update state in another component (e.g. child, sibling or parent), which then triggers an UI update.

This can be done by:
\begin{itemize}
  \item As a parent component, pass \code{props} to a child component.
        A change in props would then trigger an update in the child component.
  \item \href{https://reactjs.org/docs/context.html}{React Context} can be used to faciliate communication between components, using the \code{Provider} \& \code{Consumer} React components.
  \item State management container libraries \href{https://redux.js.org/introduction/getting-started}{Redux} or \href{https://mobx.js.org/README.html}{MobX}.
\end{itemize}

\subsubsection*{What a certain indicators that a global state management container like Redux would be needed in a React application?}
While Redux is useful, it can be cumbersome and inefficient for development in smaller applications.

Redux is most useful when:
\begin{itemize}
  \item You have large amounts of application state that are needed in many places in the app
  \item The app state is updated frequently
  \item The logic to update that state may be complex
  \item The app has a medium or large-sized codebase, and might be worked on by many people
  \item You need to see how that state is being updated over time
\end{itemize}

Reference: \url{https://redux.js.org/faq/general#when-should-i-use-redux}

\subsubsection*{Why is Reconciliation aka diffing algorithm in React?}
\href{https://reactjs.org/docs/reconciliation.html}{Reconciliation} is how React reconciles differences between the old browser DOM tree and the desired browser DOM tree to be rendered to the user.
Traditionally, state-of-art algorithms have a complexity of \(O(n^{3})\), but the diffing algorithm has been heavily optimised by the React team and runs at a complexity of \(O(n)\) heuristically.

\subsubsection*{Why does React maintain a Virtual DOM and how is it used?}
The Virtual DOM is a virtual representation of the actual browser DOM that is presented as a view in users' browsers.
It is used to optimise updates to the browser's DOM for React applications. 
In a React App, 2 Virtual DOM trees are maintained, one representing the old state, and the other representing the updated state that will eventually be used to update the actual browser DOM.

When new elements are added to a UI due to state changes, a new virtual DOM tree is created to represent the updated UI.
This newly created Virtual DOM is then compared with the old Virtual DOM through \href{https://reactjs.org/docs/reconciliation.html}{Reconciliation}, which also outputs the elements and operations to update the browser DOM to display the latest, desired UI.
This is far more efficient than modifying the browser DOM each time an element is added.

React also follows a batch update mechanism, where updates are only sent to the real DOM in batches, instead of sending everytime a state change has been detected.
This also significantly reduces the amount of time spent having to repaint UI, which is mainly the bottleneck of updating/re-rendering UI.

Reference: \url{https://programmingwithmosh.com/react/react-virtual-dom-explained/}

\end{document}